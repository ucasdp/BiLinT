
### find children of one medial node on the tree
ChildList <- function(tree, tree_PostOrder){
  # input: phylo tree
  # output: the children for each node on the tree
  N <- Ntip(tree)
  tree_childlist <- list()
  j <- 1
  for(i in 1:length(tree_PostOrder)){
    if(i > N){
      tree_childlist <- c(tree_childlist, list(Children(tree, i)))
      names(tree_childlist)[j] <- as.character(i)
      j <- j+1
    }
  }
  return(tree_childlist)
}


getDescendants<-function(tree,node,curr=NULL){
  if(is.null(curr)) curr<-vector()
  daughters<-tree$edge[which(tree$edge[,1]==node),2]
  curr<-c(curr,daughters)
  w<-which(daughters>=length(tree$tip))
  if(length(w)>0) for(i in 1:length(w))
    curr<-getDescendants(tree,daughters[w[i]],curr)
  return(curr)
}



DescList <- function(tree, tree_PreOrder){
  # input: phylo tree
  # output: the children for each node on the tree
  N <- Ntip(tree)
  tree_desclist <- list()
  for(i in 1:length(tree_PreOrder)){
    k <- tree_PreOrder[i]
    if(k > N){
      tree_desclist <- c(tree_desclist, list(getDescendants(tree, k)))
      names(tree_desclist)[i] <- as.character(k)
    }
  }
  return(tree_desclist)
}


### calculate Partials for node with two children or one child
calculatePartials_children_R <- function(Partial1, Partial2, P1, P2){
  # input: the Partials of two children and the transition matrixes from parent node to two children
  # output: the Partial of parent
  PartialParent <- (P1 %*% as.matrix(Partial1)) * (P2 %*% as.matrix(Partial2))
  return(PartialParent)
}
calculatePartials_child_R <- function(Partial1, P){
  # input: the partial of the only child, Partial1, the transition matrixes, P, from parent node to the only children
  # output: the Partial of parent
  PartialParent <- P %*% as.matrix(Partial1)
  return(PartialParent)
}

# calculate Parent Partial on the transformed tree
calculatePartials_R <- function(k, tree, state, tree_childlist, Partials, t1, t2, r, l, S){
  # input: the specific node, k;
  #        the transformed tree, tree;
  #        the children list for each node on the transformed tree, tree_childlist;
  #        the Partials list for each node on the transformed tree, Partials;
  #        scarring time t1 and t2;
  #        the scarring rate S, clock rate r, and loss rate l
  # output: calculate Partials for one node with two children or one child on the transformed tree

  children <- tree_childlist[[as.character(k)]]
  ParentPartials <- NULL
  if(length(children)==2){ # node with two children
    PartialChild1 <- Partials[[as.character(children[1])]]
    PartialChild2 <- Partials[[as.character(children[2])]]
    P1 <- P_mat_R(children[1], tree, state, t1, t2, r, l, S)
    P2 <- P_mat_R(children[2], tree, state, t1, t2, r, l, S)
    ParentPartials <- calculatePartials_children_R(PartialChild1, PartialChild2, P1, P2)
  }
  if(length(children)>2){
    PartialChild <- Partials[[as.character(children[1])]]
    P <- P_mat_R(children[1], tree, state, t1, t2, r, l, S)
    ParentPartials <- calculatePartials_child_R(PartialChild, P)
    for(i in 2:length(children)){
      PartialChild <- Partials[[as.character(children[i])]]
      # P <- P_mat_R(children[i], tree, state, t1, t2, r, l, S)
      ParentPartials <- ParentPartials * calculatePartials_child_R(PartialChild, P)
      print(ParentPartials)
    }
  }
  if(length(children)==1){# node with one children duo to scarring
    PartialChild1 <- Partials[[as.character(children)]]
    # print(PartialChild1)
    P <- P_mat_R(children, tree, state, t1, t2, r, l, S)
    # print(P)
    ParentPartials <- calculatePartials_child_R(PartialChild1, P)
  }
  return(ParentPartials)
}

At_R <- function(r,t){exp(-r*t)}
Bt_R <- function(l,t){exp(-l*t)}
Ct_R <- function(S, at, bt){
  ct <- c(1:length(S))
  for(i in 1:length(ct)){
    ct[i] <- S[i]*(bt-at)/sum(S)
  }
  ct
}
## compute transition matrix for each node
P_mat_R <- function(k, tree, state, t1, t2, r, l, S){
  # input: the specific node, k;
  #        the transformed tree, tree;
  #        all states in the sequencing data, state;
  #        scarring time t1 and t2;
  #        the scarring rate S, and loss rate l
  # output: transition matrix for a specific node

  P <- matrix(0, length(state)+2, length(state)+2)
  edge_len <- tree$edge.length
  # print(edge_len)
  names(edge_len) <- tree$edge[,2]
  dis <- get_all_distances_to_root(tree, as_edge_count=FALSE)
  nodes_Cas9 <- which(dis >= (t1+10^(-6)) & dis<=(t2+10^(-6))) # find all node on the transformed tree generated by scarring
  #nodes_Cas9 <- setdiff(nodes_Cas9, c(1:Ntip(tree)))
  if(edge_len[as.character(k)] == 0){
    edge_len[as.character(k)] = 10^(-5)
  }
  at <- At_R(r, edge_len[as.character(k)])
  # print(at)
  bt <- Bt_R(l, edge_len[as.character(k)])
  # print(bt)
  P[1, 2] <- 1 - bt
  P[2, 2] <- 1
  # print('step1:')
  # print(P)
  P[3:nrow(P), 2] <- 1 - bt
  for(i in 3:nrow(P)){
    P[i, i] <- bt
  }
  # print('step2:')
  # print(P)
  if(k %in% nodes_Cas9){
    P[1, 1] <- at
    P[1, 3:ncol(P)] <- Ct_R(S, at, bt)
  }else{
    P[1, 1] <- bt
  }
  # print('step3:')
  # print(P)
  P
}

Q_mat_R <- function(k, tree, state, t1, t2, r, l, S){
  Q <- matrix(0, length(state)+2, length(state)+2)
  dis <- get_all_distances_to_root(tree, as_edge_count=FALSE)
  nodes_Cas9 <- which(dis >= (t1+10^(-6)) & dis<=(t2+10^(-6))) # find all node on the transformed tree generated by scarring
  Q[1, 2] <- l
  Q[3:nrow(Q), 2] <- l
  for(i in 3:nrow(Q)){
    Q[i, i] <- -l
  }
  if(k %in% nodes_Cas9){
    Q[1, 1] <- -l - sum(S)
    Q[1, 3:ncol(Q)] <- S
  }else{
    Q[1, 1] <- -l
  }
  return(Q)
}


tree_likehood_R <- function(tree, state_matrix, state, t1, t2, r, l, S, log=TRUE){
  # input: the original phylo tree, tree;
  #        the sequencing data, state_matrix;
  #        scarring time t1 and t2;
  #        the scarring rate S, clock rate r, and loss rate l
  # output: likelihood of sequencing data

  tree <- tree_transform3(tree, t1, t2)
  N <- Ntip(tree)
  tree_PostOrder <- c(reorder_tree_edges(tree, root_to_tips = FALSE)$edge[,2], length(tree$tip.label)+1)
  childlist <- ChildList(tree, tree_PostOrder)
  log_lik <- 0
  for(m in 1:ncol(state_matrix)){
    Partials <- list()
    for(i in 1:length(tree_PostOrder)){
      k <- tree_PostOrder[i] ## postorder tree traversal to compute Partial
      if(k <= N){ ## for leaves
        Partial <- rep(0, length(state)+2)
        if(state_matrix[k, m]==0){
          Partial[1] <- 1
        }
        if(state_matrix[k, m]==-1){
          Partial[2] <- 1
        }
        if(!state_matrix[k, m]%in%c(0, -1)){
          Partial[match(state_matrix[k, m], state)+2] <- 1
        }

        print(k)
        print(Partial)
        # since the whole state is \Omega={unedited, silenced, scar1, scar2, . . . , scarS}, make the first two as 0
        Partials <- c(Partials, list(Partial))
      }else{ ## for medial nodes
        ParentPartials <- calculatePartials_R(k, tree, state, childlist, Partials, t1, t2, r, l, S)
        Partials <- c(Partials, list(ParentPartials))
        print(k)
        print(ParentPartials)
      }
      names(Partials)[i] <- as.character(k)
    }
    # print(Partials[[as.character(N+1)]][1,1])
    log_lik <- log_lik + log(Partials[[as.character(N+1)]][1,1])
    if(log_lik<(10^-10)){
      print(paste('loci: ', m, 'lik: ', log_lik))
    }
  }
  if(log==TRUE){
    return(log_lik)
  }else{
    return(exp(log_lik))
  }
}


tree_transform1 <- function(tree, t1, t2){
  # input: the original phylo tree and scarring time t1 and t2
  # output: the tree with nodes added at scarring time t1 and t2

  dis <- get_all_distances_to_root(tree, as_edge_count=FALSE)
  branch_lengths <- tree$edge.length
  names(branch_lengths) <- tree$edge[,2]
  splitNode1 <- NULL # point set added at time 1
  splitNode2 <- NULL # point set added at time 2
  for(i in 1:nrow(tree$edge)){
    node1 <- tree$edge[i,1]
    node2 <- tree$edge[i,2]
    if(t1 > dis[node1] && t1 < dis[node2]){
      splitNode1 <- c(splitNode1, node2) # add point on the tree at time t1 one by one
    }
  }

  # tree.a <- PCMTreeInsertSingletons(
  #   tree, nodes = as.integer(c(splitNode1,splitNode2)),
  #   positions = c(dis[splitNode1]-t1, dis[splitNode2]-t2))

  if(!is.null(splitNode1)){
    tree.a <- PCMTreeInsertSingletons(
      tree, nodes = as.integer(splitNode1),
      positions = dis[splitNode1]-t1)
    PCMTreeSetLabels(tree.a)
  }else{
    tree.a <- tree
  }


  dis <- get_all_distances_to_root(tree.a, as_edge_count=FALSE)
  for(i in 1:nrow(tree.a$edge)){
    node1 <- tree.a$edge[i,1]
    node2 <- tree.a$edge[i,2]
    if(t2 > dis[node1] && t2 < dis[node2]){
      splitNode2 <- c(splitNode2, node2) # add point on the tree at time t2 one by one
    }
  }

  if(!is.null(splitNode2)){
    tree.b <- PCMTreeInsertSingletons(
      tree.a, nodes = as.integer(splitNode2),
      positions = dis[splitNode2]-t2)
    PCMTreeSetLabels(tree.b)
  }else{
    tree.b <- tree.a
  }

  # insert all node on the tree at time t1 and t2

  return(tree.b)
}


tree_transform2 <- function(tree){
  # input: the original phylo tree
  # output: the tree with nodes added at root and leaves
  N <- Ntip(tree)
  root_des <- Children(tree, N+1)
  tree <- PCMTreeInsertSingletons(tree, nodes= root_des[1], positions = (tree$edge.length[which(tree$edge[,2]== root_des[1])]))
  insert_child <- tree$edge[1,which(names(tree$edge.length)!="")]
  other_child <- setdiff(Children(tree, N+1), tree$edge[1,which(names(tree$edge.length)!="")])
  tree$edge[which(tree$edge[,2]== other_child),1] <- insert_child
  PCMTreeSetLabels(tree)
  tree$edge.length[which(tree$edge[,1]== (N+1))] <- 1
  # plot(tree, show.node.label=TRUE, show.tip.label = TRUE)

  tree$tip.label <- paste('t',c(1:N),sep='')
  edge_length <- tree$edge.length
  tree$edge.length[which(tree$edge[,2]<=N)] <- edge_length[which(tree$edge[,2]<=N)]+1
  tree<- PCMTreeInsertSingletons(tree, nodes=paste('t',c(1:N),sep = ''), positions = rep(1, N))
  PCMTreeSetLabels(tree)
  root2_children <- Children(tree, N+2)

  # regime_pos <- as.character(c(1:(N+2), N+2))
  # names(regime_pos) <- as.character(c(1:(N+1),root2_children))

  regime_pos1 <- paste('R', c(1, 2, 2, rep(3, N)), sep='')
  names(regime_pos1) <- c((N+1), root2_children, c(1:N))

  PCMTreeSetPartRegimes(tree, part.regime = regime_pos1, setPartition = TRUE)
  palette <- PCMColorPalette(length(regime_pos1), names(regime_pos1))
  # Plot the tree with branches colored according to the regimes.
  # The following function call works only if the ggtree package is installed, # which is not on CRAN:
  PCMTreePlot(tree) + ggtree::geom_nodelab(size = 5) + geom_tiplab(size=5)
  tree_info <- list(tree= tree, regime = unique(regime_pos1))
  return(tree_info)
}







